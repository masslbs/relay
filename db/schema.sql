-- SPDX-FileCopyrightText: 2024 - 2025 Mass Labs
--
-- SPDX-License-Identifier: GPL-3.0-or-later

create type eventTypeEnum as enum ('manifest', 'listing', 'tag',  'order', 'inventory', 'account');

create table shops (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    tokenId NUMERIC(78, 0) NOT NULL,
    createdAt timestamptz NOT NULL
);

-- TODO: document why keyCards and relayKeyCards use the same sequence
-- in short, we need unique values for events.createdByKeyCardId
-- alternativly we could might make keyCards polymorphic

CREATE SEQUENCE keyCard_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1;

create table keyCards (
    id bigint DEFAULT nextval('keyCard_id_seq') PRIMARY KEY,
    cardPublicKey bytea NOT NULL,
    userWalletAddr bytea NOT NULL,
    shopId bigint NOT NULL,
    linkedAt timestamptz NOT NULL,
    unlinkedAt timestamptz,
    lastAckedSeq bigint NOT NULL,
    lastSeenAt timestamptz NOT NULL,
    lastVersion integer NOT NULL,
    isGuest boolean NOT NULL
);
create unique index keyCardsOnPublicKey on keyCards(cardPublicKey);
create index keyCardsOnUserId on keyCards(userWalletAddr);
create index keyCardsOnShopId on keyCards(shopId);

create table relayKeyCards (
    id bigint DEFAULT nextval('keyCard_id_seq') PRIMARY KEY,
    shopId bigint NOT NULL,
    cardPublicKey bytea NOT NULL,
    lastUsedAt timestamptz NOT NULL,
    lastWrittenEventNonce bigint NOT NULL
);

create table patchSets (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    keycard_nonce bigint NOT NULL,
    created_by_keycard_id bigint NOT NULL,
    created_by_shop_id bytea NOT NULL,
    shop_seq bigint NOT NULL,
    created_at timestamptz NOT NULL,
    created_by_network_schema_version bigint NOT NULL,
    received_at timestamptz NOT NULL,
    server_seq bigint NOT NULL,
    root_hash bytea NOT NULL,
    signature bytea NOT NULL
);

create table patches (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    patch_set_id bigint NOT NULL REFERENCES patchSets(id),
    op text NOT NULL CHECK (op IN ('add', 'replace', 'remove', 'increment', 'decrement')),
    object_type text NOT NULL CHECK (object_type IN ('schemaVersion', 'manifest', 'account', 'listing', 'order', 'tag', 'inventory')),
    object_id bytea, -- optional, depends on object_type
    account_id bytea, -- optional, for account patches
    tag_name text, -- optional, for tag patches
    encoded bytea NOT NULL, -- the encoded patch
    mmr_proof bytea[] NOT NULL -- array of hashes proving this patch was part of the patchset
);

-- Constraints
alter table patchSets add constraint patchSetsShopId check (octet_length(created_by_shop_id) = 8);
alter table patchSets add constraint patchSetsSignature check (octet_length(signature) = 65);
alter table patchSets add constraint patchSetsRootHash check (octet_length(root_hash) = 32);

-- Indices for patchSets
create unique index patchSetsOnServerSeq on patchSets(server_seq);
create unique index patchSetsOnKeyCardNonce on patchSets(created_by_keycard_id, keycard_nonce);
create unique index patchSetsOnShopSeq on patchSets(created_by_shop_id, shop_seq);
create index patchSetsOnCreatedByKeyCardId on patchSets(created_by_keycard_id);

-- Indices for patches
create index patchesOnObjectId on patches(object_id, created_by_shop_id);
create index patchesOnObjectType on patches(object_type, patch_set_id);
create index patchesOnAccountId on patches(account_id) where account_id is not null;
create index patchesOnTagName on patches(tag_name) where tag_name is not null;

CREATE TABLE payments (
    id            bigint GENERATED BY DEFAULT AS IDENTITY,
    orderId       bytea NOT NULL, -- see objectId in events
    shopId        bytea NOT NULL,
    shopSeqNo     bigint NOT NULL, -- the seqNo of shop when the order was finalized
    itemsLockedAt TIMESTAMP NOT NULL,

    -- set once payment method was chosen
    paymentChosenAt TIMESTAMP,
    paymentId        bytea, -- uint256
    purchaseAddr     bytea,
    chainId          integer,
    lastBlockNo      NUMERIC(80,0),
    coinsTotal       NUMERIC(80,0),
    -- (optional) set if the order is payed with an erc20 token
    erc20TokenAddr   bytea,

    -- set once payed
    payedAt     TIMESTAMP,
    payedTx     bytea,
    payedBlock  bytea,

    -- set if for e.g. a clerk cancels it or a variation was removed
    canceledAt    TIMESTAMP
);
alter table payments add constraint shopId check (octet_length(shopId) = 8);
alter table payments add constraint orderIdLength check (octet_length(orderId) = 8);
alter table payments add constraint paymentIdLength check (octet_length(paymentId) = 32);
alter table payments add constraint erc20TokenAddrCheck check (erc20TokenAddr is null OR octet_length(erc20TokenAddr) = 20);
alter table payments add constraint paymentChosen check (paymentChosenAt is null OR (
    paymentId is NOT NULL OR
    purchaseAddr is NOT NULL OR
    chainId is NOT NULL OR
    lastBlockNo is NOT NULL OR
    coinsTotal  is NOT NULL
));
alter table payments add constraint paidHash check (payedAt is null or (
    payedTx is NOT NULL OR payedBlock is NOT NULL
));

CREATE UNIQUE INDEX paymentsOrderId ON payments (shopId, orderId);
CREATE INDEX paymentsOrderFinalizedAt ON payments (paymentChosenAt);
CREATE INDEX paymentsPayedAt ON payments (payedAt);
