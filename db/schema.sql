-- SPDX-FileCopyrightText: 2024 - 2025 Mass Labs
--
-- SPDX-License-Identifier: GPL-3.0-or-later

create type objectTypeEnum as enum ('manifest', 'listing', 'tag',  'order', 'inventory', 'account');

create table shops (
    id bigint GENERATED BY DEFAULT AS IDENTITY,
    tokenId NUMERIC(78, 0) NOT NULL,
    createdAt timestamptz NOT NULL
);

-- TODO: document why keyCards and relayKeyCards use the same sequence
-- in short, we need unique values for events.createdByKeyCardId
-- alternativly we could might make keyCards polymorphic

CREATE SEQUENCE keyCardIdSeq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1;

create table keyCards (
    id bigint DEFAULT nextval('keyCardIdSeq') PRIMARY KEY,
    cardPublicKey bytea NOT NULL,
    userWalletAddr bytea NOT NULL,
    shopId bigint NOT NULL,
    linkedAt timestamptz NOT NULL,
    unlinkedAt timestamptz,
    lastAckedSeq bigint NOT NULL,
    lastSeenAt timestamptz NOT NULL,
    lastVersion integer NOT NULL,
    isGuest boolean NOT NULL
);
create unique index keyCardsOnPublicKey on keyCards(cardPublicKey);
create index keyCardsOnUserId on keyCards(userWalletAddr);
create index keyCardsOnShopId on keyCards(shopId);

create table relayKeyCards (
    id bigint DEFAULT nextval('keyCardIdSeq') PRIMARY KEY,
    shopId bigint NOT NULL,
    cardPublicKey bytea NOT NULL,
    lastUsedAt timestamptz NOT NULL,
    lastWrittenEventNonce bigint NOT NULL
);

create table patchSets (
    serverSeq bigint NOT NULL primary key,
    keycardNonce bigint NOT NULL,
    createdByKeyCardId bigint NOT NULL,
    createdByShopId bytea NOT NULL,
    shopSeq bigint NOT NULL,
    createdAt timestamptz NOT NULL,
    createdByNetworkSchemaVersion bigint NOT NULL,
    receivedAt timestamptz NOT NULL,
    header bytea NOT NULL, -- CBOR encoded patchset header
    signature bytea NOT NULL 
);
alter table patchSets add constraint patchSetsShopId check (octet_length(createdByShopId) = 8);
alter table patchSets add constraint patchSetsSignature check (octet_length(signature) = 65);
alter table patchSets add constraint patchSetsHeader check (octet_length(header) > 1);

create unique index patchSetsOnServerSeq on patchSets(serverSeq);
create unique index patchSetsOnKeyCardNonce on patchSets(createdByKeyCardId, keycardNonce);
create unique index patchSetsOnShopSeq on patchSets(createdByShopId, shopSeq);
create index patchSetsOnShopSeqAndKeyCardId on patchSets(createdByShopId,createdByKeyCardId);

create table patches (
    patchSetServerSeq bigint NOT NULL REFERENCES patchSets(serverSeq),
    patchIndex integer NOT NULL, -- index of the patch in the patch set
   
    encoded bytea NOT NULL, -- CBOR encoded patch
    mmrProof bytea NOT NULL, -- CBOR array: [leaf_index, tree_size, [proof_1, ...]] see https://github.com/masslbs/network-schema/blob/main/pkg/mmr/mmr.go
   
    -- redundant, but helps with queries
    op text NOT NULL CHECK (op IN ('add', 'replace', 'remove', 'increment', 'decrement')),
    objectType objectTypeEnum NOT NULL, 
    objectId bytea, -- optional, depends on objectType
    accountAddr bytea, -- optional, for account patches
    tagName text -- optional, for tag patches
);
alter table patches add constraint patchesObjectId check (
    (objectType in ('listing', 'order', 'inventory') and octet_length(objectId) = 8) or
    (objectType = 'manifest' and objectId is null) or 
    (objectType = 'account' and objectId is null) or
    (objectType = 'tag' and objectId is null)
);
alter table patches add constraint patchesAccountAddr check (
    (objectType = 'account' and octet_length(accountAddr) = 20) or
    (objectType != 'account' and accountAddr is null)
);
alter table patches add constraint patchesTagName check (
    (objectType = 'tag' and tagName is not null and length(tagName) > 0) or
    (objectType != 'tag' and tagName is null)
);

-- Indices for patches
create unique index patchesOnPatchSetServerSeqAndPatchIndex on patches(patchSetServerSeq, patchIndex);
create index patchesOnObjectType on patches(objectType, patchSetServerSeq);
create index patchesOnAccountAddr on patches(accountAddr) where accountAddr is not null;

CREATE TABLE payments (
    id            bigint GENERATED BY DEFAULT AS IDENTITY,
    orderId       bytea NOT NULL, -- see objectId in events
    shopId        bytea NOT NULL,
    shopSeqNo     bigint NOT NULL, -- the seqNo of shop when the order was finalized
    itemsLockedAt TIMESTAMP NOT NULL,

    -- set once payment method was chosen
    paymentChosenAt TIMESTAMP,
    paymentId        bytea, -- uint256
    purchaseAddr     bytea,
    chainId          integer,
    lastBlockNo      NUMERIC(80,0),
    coinsTotal       NUMERIC(80,0),
    -- (optional) set if the order is payed with an erc20 token
    erc20TokenAddr   bytea,

    -- set once payed
    payedAt     TIMESTAMP,
    payedTx     bytea,
    payedBlock  bytea,

    -- set if for e.g. a clerk cancels it or a variation was removed
    canceledAt    TIMESTAMP
);
alter table payments add constraint shopId check (octet_length(shopId) = 8);
alter table payments add constraint orderIdLength check (octet_length(orderId) = 8);
alter table payments add constraint paymentIdLength check (octet_length(paymentId) = 32);
alter table payments add constraint erc20TokenAddrCheck check (erc20TokenAddr is null OR octet_length(erc20TokenAddr) = 20);
alter table payments add constraint paymentChosen check (paymentChosenAt is null OR (
    paymentId is NOT NULL OR
    purchaseAddr is NOT NULL OR
    chainId is NOT NULL OR
    lastBlockNo is NOT NULL OR
    coinsTotal  is NOT NULL
));
alter table payments add constraint paidHash check (payedAt is null or (
    payedTx is NOT NULL OR payedBlock is NOT NULL
));

CREATE UNIQUE INDEX paymentsOrderId ON payments (shopId, orderId);
CREATE INDEX paymentsOrderFinalizedAt ON payments (paymentChosenAt);
CREATE INDEX paymentsPayedAt ON payments (payedAt);
